[1mdiff --git a/src/games/ToiletPaperToss.js b/src/games/ToiletPaperToss.js[m
[1mindex 3532953..f731b6b 100644[m
[1m--- a/src/games/ToiletPaperToss.js[m
[1m+++ b/src/games/ToiletPaperToss.js[m
[36m@@ -11,7 +11,7 @@[m [mimport React, { useRef, useState, useEffect } from 'react';[m
 import { StyleSheet, View, Dimensions, Text, Image, ImageBackground, TouchableOpacity, Modal } from 'react-native';[m
 import { Ionicons } from '@expo/vector-icons';[m
 import { GameEngine } from 'react-native-game-engine';[m
[31m-import Matter from 'matter-js';[m
[32m+[m[32mimport Matter, { Bodies, World, Composite, Runner, Body } from 'matter-js';[m
 import { Audio } from 'expo-av';[m
 import Svg, { Polygon, Circle as SvgCircle, Rect } from 'react-native-svg';[m
 import AimPad from '../../components/AimPad';[m
[36m@@ -24,6 +24,41 @@[m [mMatter.Common.setDecomp(decomp);[m
 [m
 const { width: WIDTH, height: HEIGHT } = Dimensions.get('window');[m
 [m
[32m+[m[32m// Helper functions for ensuring physics runner and TP body are valid[m
[32m+[m[32mconst runnerRef = { current: null };[m
[32m+[m
[32m+[m[32mfunction ensureRunner(engine) {[m
[32m+[m[32m  if (!runnerRef.current) {[m
[32m+[m[32m    runnerRef.current = Runner.create();[m
[32m+[m[32m    Runner.run(runnerRef.current, engine);[m
[32m+[m[32m  }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mfunction ensureTpBody(engine, bodies) {[m
[32m+[m[32m  const world = engine.world;[m
[32m+[m[32m  let tp = bodies.tp;[m
[32m+[m[32m  const isBad =[m
[32m+[m[32m    !tp ||[m
[32m+[m[32m    !isFinite(tp.position?.x) ||[m
[32m+[m[32m    !isFinite(tp.position?.y) ||[m
[32m+[m[32m    Composite.allBodies(world).indexOf(tp) === -1;[m
[32m+[m
[32m+[m[32m  if (isBad) {[m
[32m+[m[32m    if (tp) try { World.remove(world, tp); } catch {}[m
[32m+[m[32m    tp = Bodies.circle(-9999, -9999, 18, { // Using hardcoded TP_RADIUS value[m
[32m+[m[32m      label: "TP",[m
[32m+[m[32m      restitution: 0.45,[m
[32m+[m[32m      friction: 0.05,[m
[32m+[m[32m      frictionAir: 0.012,[m
[32m+[m[32m      density: 0.0016,[m
[32m+[m[32m      isStatic: true,[m
[32m+[m[32m    });[m
[32m+[m[32m    World.add(world, tp);[m
[32m+[m[32m    bodies.tp = tp; // IMPORTANT: update your shared reference[m
[32m+[m[32m  }[m
[32m+[m[32m  return tp;[m
[32m+[m[32m}[m
[32m+[m
 // Sound effects[m
 let dingSound = null;[m
 let waterDropSound = null;[m
[36m@@ -520,90 +555,60 @@[m [mexport default function ToiletPaperToss({ onGameComplete, gameMode }) {[m
   // Keep last aim from AimPad[m
   const lastAimRef = useRef(null);[m
 [m
[31m-  // Bulletproof launch function[m
[31m-  const doLaunch = () => {[m
[31m-    console.log('doLaunch called');[m
[31m-    const a = lastAimRef.current;[m
[31m-    const tp = bodies?.tp;                           // stick to ONE body reference[m
[31m-    console.log('doLaunch check:', { hasAim: !!a, hasTp: !!tp, aim: a });[m
[31m-    if (!a || !tp) { [m
[31m-      console.log('doLaunch: Missing aim or TP, returning');[m
[31m-      return; [m
[31m-    }[m
[31m-[m
[31m-    // spawn at pad center (with fallback)[m
[31m-    const spawn = { [m
[31m-      x: a.origin?.x || WIDTH / 2, [m
[31m-      y: a.origin?.y || HEIGHT - 24 - 90 [m
[31m-    };[m
[31m-[m
[31m-[m
[31m-[m
[31m-    // Ensure spawn coordinates are valid numbers[m
[31m-    if (!Number.isFinite(spawn.x) || !Number.isFinite(spawn.y)) {[m
[32m+[m[32m  // Guarded visibility function to prevent TP from being hidden during flight[m
[32m+[m[32m  function setTpVisibleGuarded(val, reason = "") {[m
[32m+[m[32m    // don't allow hiding immediately after a launch[m
[32m+[m[32m    if (!val && Date.now() < (stateRef.current.justLaunchedUntil || 0)) {[m
[32m+[m[32m      // console.log("VIS GUARD blocked hide:", reason);[m
       return;[m
     }[m
[32m+[m[32m    setTpVisible(val);[m
[32m+[m[32m  }[m
 [m
[31m-    // wake + place[m
[31m-    Matter.Body.setStatic(tp, false);[m
[31m-    Matter.Sleeping.set(tp, false);[m
[31m-    Matter.Body.setPosition(tp, spawn);[m
[31m-    Matter.Body.setVelocity(tp, { x: 0, y: 0 });[m
[31m-    Matter.Body.setAngularVelocity(tp, 0);[m
[31m-[m
[31m-    // Verify the body position was set correctly[m
[31m-    const newPos = tp.position;[m
[31m-    if (!Number.isFinite(newPos.x) || !Number.isFinite(newPos.y)) {[m
[31m-      // Create a new body if the current one is corrupted[m
[31m-      const newTp = Matter.Bodies.circle(spawn.x, spawn.y, CONSTANTS.TP_RADIUS, {[m
[31m-        restitution: 0.45,[m
[31m-        friction: 0.05,[m
[31m-        frictionAir: 0.012,[m
[31m-        density: 0.0016,[m
[31m-        label: 'TP'[m
[31m-      });[m
[31m-      [m
[31m-      // Remove old body and add new one[m
[31m-      Matter.World.remove(world, tp);[m
[31m-      Matter.World.add(world, newTp);[m
[31m-      [m
[31m-      // Update the reference[m
[31m-      bodies.tp = newTp;[m
[31m-      [m
[31m-      // Set velocity on the new body[m
[31m-      const rawP = a.power || 0;[m
[31m-      const p = Math.max(0.25, Math.min(1, rawP));[m
[31m-      const SPEED = 16.2;  // Reduced acceleration (10% less) for smoother launch[m
[31m-      const vx = (a.dir?.x || 0) * SPEED * p;[m
[31m-      const vy = -(Math.abs(a.dir?.y || 0)) * SPEED * p;[m
[31m-      [m
[31m-      Matter.Body.setVelocity(newTp, { x: vx, y: vy });[m
[31m-      Matter.Body.setAngularVelocity(newTp, 0.2 * p);[m
[31m-      [m
[31m-      setTpPos(spawn);[m
[31m-      setTpVisible(true);[m
[31m-      [m
[32m+[m[32m  // Bulletproof launch function[m
[32m+[m[32m  const doLaunch = (aimData) => {[m
[32m+[m[32m    console.log('doLaunch called with aimData:', aimData);[m
[32m+[m[32m    const a = aimData || lastAimRef.current;[m
[32m+[m[32m    console.log('doLaunch: using aim data =', a);[m
[32m+[m[32m    console.log('doLaunch: a?.origin =', a?.origin);[m
[32m+[m[32m    if (!a?.origin) {[m
[32m+[m[32m      console.log('doLaunch: Missing aim or origin, returning');[m
       return;[m
     }[m
 [m
[31m-    // power from AimPad drag distance; add a safe minimum[m
[31m-    const rawP = a.power || 0;[m
[31m-    const p = Math.max(0.25, Math.min(1, rawP));     // TEMP min power 25%[m
[31m-    const SPEED = 16.2;  // Reduced acceleration (10% less) for smoother launch[m
[32m+[m[32m    // 1) Kill old body (if any), create a fresh one at the spawn point[m
[32m+[m[32m    try { if (bodies.tp) Matter.World.remove(engine.world, bodies.tp); } catch {}[m
[32m+[m[32m    const tp = Matter.Bodies.circle(a.origin.x, a.origin.y, 18, {[m
[32m+[m[32m      label: "TP",[m
[32m+[m[32m      restitution: 0.45,[m
[32m+[m[32m      friction: 0.05,[m
[32m+[m[32m      frictionAir: 0.012,[m
[32m+[m[32m      density: 0.0016,[m
[32m+[m[32m    });[m
[32m+[m[32m    Matter.World.add(engine.world, tp);[m
[32m+[m[32m    bodies.tp = tp;[m
 [m
[31m-    // portrait: up is negative Y[m
[32m+[m[32m    // 2) Compute velocity (portrait: up is -Y). Keep your charge logic if you have it.[m
[32m+[m[32m    const SPEED = 18;[m
[32m+[m[32m    const p = Math.max(0.2, Math.min(1, (stateRef.current?.charge ?? 0) / 100 || a.power || 0));[m
     const vx = (a.dir?.x || 0) * SPEED * p;[m
     const vy = -(Math.abs(a.dir?.y || 0)) * SPEED * p;[m
 [m
[32m+[m[32m    // 3) Wake & throw[m
[32m+[m[32m    Matter.Body.setStatic(tp, false);[m
[32m+[m[32m    Matter.Sleeping.set(tp, false);[m
     Matter.Body.setVelocity(tp, { x: vx, y: vy });[m
     Matter.Body.setAngularVelocity(tp, 0.2 * p);[m
 [m
[32m+[m[32m    // 4) First-frame UI sync[m
[32m+[m[32m    setTpPos({ x: a.origin.x, y: a.origin.y });[m
[32m+[m[32m    stateRef.current.isFlying = true;[m
[32m+[m[32m    stateRef.current.justLaunchedUntil = Date.now() + 400;[m
[32m+[m[32m    setTpVisibleGuarded(true, "launch");[m
 [m
[31m-[m
[31m-    // FIRST-FRAME SYNC + show sprite in the SAME component that renders it[m
[31m-    // Force immediate sync to prevent afterUpdate from overwriting[m
[31m-    setTpPos(spawn);[m
[31m-    setTpVisible(true);[m
[32m+[m[32m    // 5) Reset charge UI (unchanged)[m
[32m+[m[32m    stateRef.current.isCharging = false;[m
[32m+[m[32m    stateRef.current.charge = 0;[m
   };[m
 [m
   const stateRef = useRef({[m
[36m@@ -619,6 +624,9 @@[m [mexport default function ToiletPaperToss({ onGameComplete, gameMode }) {[m
     padPower: 0,[m
     padOrigin: null,[m
     padVel: null,[m
[32m+[m[32m    // Post-launch ignore window[m
[32m+[m[32m    justLaunchedUntil: 0,[m
[32m+[m[32m    isFlying: false,[m
   });[m
 [m
   // Load sounds[m
[36m@@ -637,14 +645,14 @@[m [mexport default function ToiletPaperToss({ onGameComplete, gameMode }) {[m
       if (aimPadRef.current) {[m
         setTimeout(() => {[m
           aimPadRef.current.prime();[m
[31m-          // Reset TP to starting position after priming[m
[31m-          if (bodies.tp) {[m
[31m-            Matter.Body.setStatic(bodies.tp, true);[m
[31m-            Matter.Body.setPosition(bodies.tp, { x: -9999, y: -9999 });[m
[31m-            Matter.Body.setVelocity(bodies.tp, { x: 0, y: 0 });[m
[31m-            Matter.Body.setAngularVelocity(bodies.tp, 0);[m
[31m-            setTpVisible(false);[m
[31m-          }[m
[32m+[m[32m                     // Reset TP to starting position after priming[m
[32m+[m[32m           if (bodies.tp) {[m
[32m+[m[32m             Matter.Body.setStatic(bodies.tp, true);[m
[32m+[m[32m             Matter.Body.setPosition(bodies.tp, { x: -9999, y: -9999 });[m
[32m+[m[32m             Matter.Body.setVelocity(bodies.tp, { x: 0, y: 0 });[m
[32m+[m[32m             Matter.Body.setAngularVelocity(bodies.tp, 0);[m
[32m+[m[32m             setTpVisibleGuarded(false, "priming");[m
[32m+[m[32m           }[m
         }, 500); // Wait for everything to be ready[m
       }[m
     };[m
[36m@@ -756,25 +764,34 @@[m [mexport default function ToiletPaperToss({ onGameComplete, gameMode }) {[m
     engine.world.gravity.y = CONSTANTS.GRAVITY_Y;[m
     [m
     let updateCount = 0;[m
[31m-    Matter.Events.on(engine, "afterUpdate", () => {[m
[31m-      updateCount++;[m
[31m-      [m
[31m-      const tp = bodies?.tp;[m
[31m-      if (!tp) {[m
[31m-        return;[m
[31m-      }[m
[31m-      const p = tp.position;[m
[31m-      [m
[31m-      // Always update tpPos if TP is visible and position is valid[m
[31m-      if (tpVisible && Number.isFinite(p.x) && Number.isFinite(p.y)) {[m
[31m-        setTpPos({ x: p.x, y: p.y });[m
[31m-      }[m
[31m-      [m
[31m-      // Hide TP when it falls off screen or stops moving[m
[31m-      if (tpVisible && tp.position.y > HEIGHT + 100) {[m
[31m-        setTpVisible(false);[m
[31m-      }[m
[31m-    });[m
[32m+[m[32m                   Matter.Events.on(engine, "afterUpdate", () => {[m
[32m+[m[32m        updateCount++;[m
[32m+[m[41m        [m
[32m+[m[32m        const tp = bodies?.tp;[m
[32m+[m[32m        if (!tp) {[m
[32m+[m[32m          return;[m
[32m+[m[32m        }[m
[32m+[m[32m        const p = tp.position;[m
[32m+[m[41m        [m
[32m+[m[32m        // Always update tpPos if position is valid[m
[32m+[m[32m        if (Number.isFinite(p.x) && Number.isFinite(p.y)) {[m
[32m+[m[32m          setTpPos({ x: p.x, y: p.y });[m
[32m+[m[32m        }[m
[32m+[m[41m        [m
[32m+[m[32m        // keep TP shown while flying (overwrites any stray UI hides)[m
[32m+[m[32m        if (stateRef.current.isFlying) setTpVisibleGuarded(true, "flying");[m
[32m+[m[41m        [m
[32m+[m[32m        const v2 = tp.velocity.x * tp.velocity.x + tp.velocity.y * tp.velocity.y;[m
[32m+[m[32m        const stopped = v2 < 0.5;[m
[32m+[m[41m        [m
[32m+[m[32m        const oob = tp.position.x < -80 || tp.position.x > WIDTH + 80 ||[m
[32m+[m[32m                    tp.position.y < -80 || tp.position.y > HEIGHT + 80;[m
[32m+[m[41m        [m
[32m+[m[32m        if (stopped || oob) {[m
[32m+[m[32m          stateRef.current.isFlying = false;[m
[32m+[m[32m          setTpVisibleGuarded(false, "stopped/oob");[m
[32m+[m[32m        }[m
[32m+[m[32m      });[m
 [m
     return () => {[m
       Matter.Events.off(engine, "afterUpdate");[m
[36m@@ -866,24 +883,31 @@[m [mexport default function ToiletPaperToss({ onGameComplete, gameMode }) {[m
                  <AimPad[m
            ref={aimPadRef}[m
            radius={74.25}[m
[31m-           onAim={({ dir, power, active, origin }) => {[m
[31m-             console.log('Game onAim:', { dir, power, active, origin });[m
[31m-             lastAimRef.current = { dir, power, origin };[m
[31m-             stateRef.current.padActive = !!active;[m
[31m-[m
[31m-             // start charge only while aiming[m
[31m-             if (active && !stateRef.current.isCharging) {[m
[31m-               stateRef.current.isCharging = true;[m
[31m-               stateRef.current.charge = 0;        // start from 0 each aim[m
[31m-               stateRef.current.chargeDir = 1;     // ping-pong up first[m
[31m-             }[m
[31m-           }}[m
[31m-           onRelease={() => {[m
[31m-             console.log('Game onRelease called');[m
[31m-             stateRef.current.isCharging = false;  // <-- stop the meter[m
[31m-             stateRef.current.charge = 0;          // reset for next shot[m
[31m-             doLaunch();                            // call your launch fn (below)[m
[31m-           }}[m
[32m+[m[32m                       onAim={({ dir, power, active, origin }) => {[m
[32m+[m[32m              // Ignore stray post-release aim events[m
[32m+[m[32m              if (Date.now() < (stateRef.current.justLaunchedUntil || 0)) return;[m
[32m+[m[41m              [m
[32m+[m[32m              console.log('Game onAim:', { dir, power, active, origin });[m
[32m+[m[32m              if (active) {[m
[32m+[m[32m                lastAimRef.current = { dir, power, origin };[m
[32m+[m[32m                console.log('Game onAim: Set lastAimRef.current to:', lastAimRef.current);[m
[32m+[m[32m              }[m
[32m+[m[32m              stateRef.current.padActive = !!active;[m
[32m+[m
[32m+[m[32m              // start charge only while aiming[m
[32m+[m[32m              if (active && !stateRef.current.isCharging) {[m
[32m+[m[32m                stateRef.current.isCharging = true;[m
[32m+[m[32m                stateRef.current.charge = 0;        // start from 0 each aim[m
[32m+[m[32m                stateRef.current.chargeDir = 1;     // ping-pong up first[m
[32m+[m[32m              }[m
[32m+[m[32m            }}[m
[32m+[m[32m                       onRelease={() => {[m
[32m+[m[32m              console.log('Game onRelease called');[m
[32m+[m[32m              console.log('Game onRelease: lastAimRef.current before doLaunch =', lastAimRef.current);[m
[32m+[m[32m              stateRef.current.isCharging = false;  // <-- stop the meter[m
[32m+[m[32m              stateRef.current.charge = 0;          // reset for next shot[m
[32m+[m[32m              doLaunch(lastAimRef.current);         // pass aim data directly[m
[32m+[m[32m            }}[m
          />[m
 [m
 [m
[36m@@ -910,48 +934,32 @@[m [mexport default function ToiletPaperToss({ onGameComplete, gameMode }) {[m
           />[m
         </View>[m
 [m
[31m-        {/* TP sprite — bulletproof rendering with rotation */}[m
[31m-        {tpVisible && Number.isFinite(tpPos.x) && Number.isFinite(tpPos.y) && ([m
[31m-          <Image[m
[31m-            source={require('../../assets/tp.png')}   // verify path![m
[31m-            style={{ [m
[31m-              position:'absolute', [m
[31m-              left: tpPos.x - 28, [m
[31m-              top: tpPos.y - 28, [m
[31m-              width:56, [m
[31m-              height:56, [m
[31m-              zIndex:20,[m
[31m-              transform: [{ rotate: `${bodies.tp.angle * (180 / Math.PI)}deg` }] // Convert radians to degrees[m
[31m-            }}[m
[31m-            resizeMode="contain"[m
[31m-            onLoad={() => console.log('TP image loaded successfully')}[m
[31m-            onError={(error) => {[m
[31m-              console.error('TP image failed to load:', error);[m
[31m-              // Only show red circle if image fails to load[m
[31m-            }}[m
[31m-          />[m
[31m-        )}[m
[31m-        [m
[31m-        {/* Debug: Show TP position as a simple colored circle ONLY if image fails */}[m
[31m-        {/* {tpVisible && Number.isFinite(tpPos.x) && Number.isFinite(tpPos.y) && ([m
[31m-          <View[m
[31m-            style={{[m
[31m-              position: 'absolute',[m
[31m-              left: tpPos.x - 28,[m
[31m-              top: tpPos.y - 28,[m
[31m-              width: 56,[m
[31m-              height: 56,[m
[31m-              borderRadius: 28,[m
[31m-              backgroundColor: '#FF6B6B',[m
[31m-              borderWidth: 2,[m
[31m-              borderColor: '#fff',[m
[31m-              zIndex: 19[m
[31m-            }}[m
[31m-          />[m
[31m-        )} */}[m
[31m-[m
[31m-[m
[31m-      </ImageBackground>[m
[32m+[m[32m               </ImageBackground>[m
[32m+[m
[32m+[m[32m       {/* TP sprite — root-level overlay to prevent clipping */}[m
[32m+[m[32m       <View[m
[32m+[m[32m         pointerEvents="none"[m
[32m+[m[32m         style={{ position: "absolute", left: 0, top: 0, right: 0, bottom: 0, overflow: "visible", zIndex: 9999 }}[m
[32m+[m[32m       >[m
[32m+[m[32m         {tpVisible && Number.isFinite(tpPos.x) && Number.isFinite(tpPos.y) && ([m
[32m+[m[32m           <Image[m
[32m+[m[32m             source={require('../../assets/tp.png')}[m
[32m+[m[32m             style={{[m[41m [m
[32m+[m[32m               position: 'absolute',[m[41m [m
[32m+[m[32m               left: tpPos.x - 28,[m[41m [m
[32m+[m[32m               top: tpPos.y - 28,[m[41m [m
[32m+[m[32m               width: 56,[m[41m [m
[32m+[m[32m               height: 56,[m
[32m+[m[32m               transform: [{ rotate: `${bodies.tp.angle * (180 / Math.PI)}deg` }] // Convert radians to degrees[m
[32m+[m[32m             }}[m
[32m+[m[32m             resizeMode="contain"[m
[32m+[m[32m             onLoad={() => console.log('TP image loaded successfully')}[m
[32m+[m[32m             onError={(error) => {[m
[32m+[m[32m               console.error('TP image failed to load:', error);[m
[32m+[m[32m             }}[m
[32m+[m[32m           />[m
[32m+[m[32m         )}[m
[32m+[m[32m       </View>[m
 [m
       <Modal[m
         transparent[m
