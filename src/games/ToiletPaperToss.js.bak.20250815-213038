// ToiletPaperToss.js
// Expo React Native + react-native-game-engine + matter-js starter for the Toilet Paper Toss game
// Features:
// - Slingshot-style aiming (drag back like Angry Birds)

// - Toilet paper (circle body) bounces off walls/ceiling/toilet
// - Touching the ground ends the turn and resets the paper
// - Tunable physics so the paper actually FLIES

import React, { useRef, useState, useEffect } from 'react';
import { StyleSheet, View, Dimensions, Text, Image, ImageBackground, TouchableOpacity, Modal } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { GameEngine } from 'react-native-game-engine';
import Matter from 'matter-js';
import { Audio } from 'expo-av';
import Svg, { Polygon, Circle as SvgCircle, Rect } from 'react-native-svg';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import AxisAimPad from '../components/input/AxisAimPad';
import TrajectoryOverlay from '../../components/TrajectoryOverlay';
import GameHUD from '../ui/GameHUD';
import LevelUpBanner from '../components/LevelUpBanner';
import PracticeCustomizationModal from '../components/PracticeCustomizationModal';
import { saveHighScore, loadHighScore } from '../utils/highScore';

// Set up poly-decomp for Matter.js concave shapes
import decomp from 'poly-decomp';
Matter.Common.setDecomp(decomp);

const { width: WIDTH, height: HEIGHT } = Dimensions.get('window');

// Sound effects
let dingSound = null;
let waterDropSound = null;

const loadSounds = async () => {
  try {
    const { sound: ding } = await Audio.Sound.createAsync(
      require('../../assets/ding.mp3')
    );
    dingSound = ding;
    
    const { sound: water } = await Audio.Sound.createAsync(
      require('../../assets/water_drop.mp3')
    );
    waterDropSound = water;
  } catch (error) {
    console.log('Could not load sound effect:', error);
  }
};

const playDingSound = async () => {
  if (dingSound) {
    try {
      await dingSound.replayAsync();
    } catch (error) {
      console.log('Could not play sound:', error);
    }
  }
};

const playWaterDropSound = async () => {
  if (waterDropSound) {
    try {
      await waterDropSound.replayAsync();
    } catch (error) {
      console.log('Could not play water drop sound:', error);
    }
  }
};

/******************** Utility Renderers ********************/
const Circle = ({ body, color = '#ffffff', radius = 16, imageSource, hidden }) => {
  if (hidden) return null;
  const x = body.position.x - radius;
  const y = body.position.y - radius;
  return (
    <View style={[{
      position: 'absolute',
      left: x,
      top: y,
      width: radius * 2,
      height: radius * 2,
      borderRadius: radius,
      backgroundColor: color,
      borderWidth: 2,
      borderColor: '#222'
    }]}>
      {imageSource && (
        <Image
          source={imageSource}
          style={{
            width: '100%',
            height: '100%',
            borderRadius: radius,
          }}
          resizeMode="contain"
        />
      )}
    </View>
  );
};

const Box = ({ body, color = '#888' }) => {
  const { min, max } = body.bounds;
  const w = max.x - min.x;
  const h = max.y - min.y;
  const x = min.x;
  const y = min.y;
  return (
    <View style={[{
      position: 'absolute',
      left: x,
      top: y,
      width: w,
      height: h,
      backgroundColor: color,
      borderWidth: 1,
      borderColor: '#333'
    }]} />
  );
};



// Toilet sprite bound to physics body
const ToiletSprite = ({ body }) => {
  const { min, max } = body.bounds;
  const w = max.x - min.x;
  const h = max.y - min.y;
  const x = min.x;
  const y = min.y;
  return (
    <View style={{ position: 'absolute', left: x, top: y, width: w, height: h }}>
      <Image source={require('../../assets/toilet.png')} style={{ width: '100%', height: '100%' }} resizeMode="contain" />
    </View>
  );
};

// Debug: Visualize static bodies to find invisible walls
const StaticBodiesOverlay = ({ engine }) => {
  if (!engine) return null;
  const bodies = Matter.Composite.allBodies(engine.world).filter(b => b.isStatic);
  return (
    <>
      {bodies.map((b, i) => {
        const bb = b.bounds;
        const left = bb.min.x, top = bb.min.y;
        const width = bb.max.x - bb.min.x, height = bb.max.y - bb.min.y;
        // Skip huge offscreen parking rects if you have any
        if (!isFinite(left) || !isFinite(top) || width <= 0 || height <= 0) return null;
        return (
          <View key={i} style={{
            position: "absolute",
            left, top, width, height,
            borderWidth: 2,
            borderColor: "rgba(255,0,0,0.8)",
            backgroundColor: "rgba(255,0,0,0.15)",
            zIndex: 999,
          }} />
        );
      })}
    </>
  );
};

// Bowl hitbox debug overlay
const BowlHitboxOverlay = ({ engine }) => {
  if (!engine) return null;
  
  const bowlBodies = Matter.Composite.allBodies(engine.world).filter(b => 
    b.label === "BOWL_SIDE_L" || b.label === "BOWL_SIDE_R" || b.label === "BOWL_BOTTOM" || b.label === "BOWL_SENSOR"
  );
  
  // Debug: Log bowl bodies found (only once)
  if (bowlBodies.length === 0) {

  }
  
  if (bowlBodies.length === 0) return null;

  return (
    <View style={{
      position: "absolute",
      left: 0,
      top: 0,
      width: WIDTH,
      height: HEIGHT,
      zIndex: 998,
      pointerEvents: "none", // Allow touch events to pass through
    }}>
      <Svg width={WIDTH} height={HEIGHT}>
        {bowlBodies.map((body, index) => {
          if (body.label === "BOWL_MAIN") {
            // Circle for main bowl
            return (
              <SvgCircle
                key={index}
                cx={body.position.x}
                cy={body.position.y}
                r={body.circleRadius}
                fill="rgba(255,0,0,0.2)"
                stroke="rgba(255,0,0,1)"
                strokeWidth="3"
              />
            );
          } else {
            // Rectangle for walls and top
            const bounds = body.bounds;
            const width = bounds.max.x - bounds.min.x;
            const height = bounds.max.y - bounds.min.y;
            return (
              <Rect
                key={index}
                x={bounds.min.x}
                y={bounds.min.y}
                width={width}
                height={height}
                fill="rgba(255,0,0,0.2)"
                stroke="rgba(255,0,0,1)"
                strokeWidth="3"
              />
            );
          }
        })}
      </Svg>
    </View>
  );
};

// Bottom-center Press button used to start charging/aiming
const ShootButton = ({ held, onLayoutRect, onPressIn, onDrag, onRelease }) => {
  const size = 96;
  const viewRef = React.useRef(null);

  const reportLayout = () => {
    if (viewRef.current && typeof viewRef.current.measureInWindow === 'function') {
      viewRef.current.measureInWindow((x, y, width, height) => {
        const rect = { x, y, w: width, h: height };
        const anchor = { x: x + width / 2, y: y }; // top-center of button
        onLayoutRect && onLayoutRect(rect, anchor);
      });
    }
  };

  return (
    <View
      ref={viewRef}
      style={styles.shootButton}
      onLayout={reportLayout}
      onStartShouldSetResponder={() => true}
      onResponderGrant={(e) => {
        reportLayout();
        const { pageX: x, pageY: y } = e.nativeEvent;
        onPressIn && onPressIn({ x, y });
      }}
      onResponderMove={(e) => {
        const { pageX: x, pageY: y } = e.nativeEvent;
        onDrag && onDrag({ x, y });
      }}
      onResponderRelease={() => onRelease && onRelease()}
    >
      <Image
        source={held ? require('../../assets/button_depressed.png') : require('../../assets/button.png')}
        style={{ width: size, height: size }}
        resizeMode="contain"
      />
    </View>
  );
};

/******************** Constants ********************/
const CONSTANTS = {
  TP_RADIUS: 18,
  START_X: WIDTH * 0.50, // Start center horizontally
  START_Y: HEIGHT - 24 - 56 - 50, // Above the AimPad
  MAX_AIM_LEN: 160, // px drag clamp
  MAX_IMPULSE: 0.12, // scale for Matter.applyForce (tune 0.04..0.14)
  GRAVITY_Y: 0.15, // Fine-tuned gravity for optimal travel time
};

/******************** World Factory ********************/

// Clean arena builder
const buildArena = (engine, W, H, tpBody) => {
  const world = engine.world;

  // Remove all bodies except TP
  Matter.Composite.allBodies(world).forEach(b => {
    if (b !== tpBody) Matter.World.remove(world, b);
  });

  // Add floor, ceiling, left wall, right wall
  const wall = { isStatic: true, label: "BOUNDARY" };
  const walls = [
    Matter.Bodies.rectangle(W / 2, H + 40, W, 80, wall),   // floor
    Matter.Bodies.rectangle(W / 2, -40, W, 80, wall),      // ceiling
    Matter.Bodies.rectangle(-40, H / 2, 80, H, wall),      // left
    Matter.Bodies.rectangle(W + 40, H / 2, 80, H, wall),   // right
  ];
  Matter.World.add(world, walls);
};

// Remove any old rim that blocks the opening
const removeOldRims = (engine) => {
  const world = engine.world;
  Matter.Composite.allBodies(world).forEach(b => {
    if (["BOWL_RIM", "BOWL", "BOWL_RING"].includes(b.label)) {
      Matter.World.remove(world, b);
    }
  });
};

// Add an open-top bowl (left + right + curved bottom + sensor)
const addOpenBowl = (engine, bx, by, r = 42) => {
  const world = engine.world;
  const thickness = 16;               // wall thickness (px)
  const tilt = 0.35;                  // wall inward tilt (radians ~20Â°)

  // Material tuned to "slide in", not bounce out
  const mat = { 
    isStatic: true, 
    restitution: 0.05, 
    friction: 0.25, 
    frictionStatic: 0.9 
  };

  // Left inner wall (tilted inward)
  const left = Matter.Bodies.rectangle(bx - r * 0.9, by + r * 0.1, thickness, r * 1.6, {
    ...mat, 
    angle: -tilt, 
    label: "BOWL_SIDE_L"
  });

  // Right inner wall (tilted inward)
  const right = Matter.Bodies.rectangle(bx + r * 0.9, by + r * 0.1, thickness, r * 1.6, {
    ...mat, 
    angle: tilt, 
    label: "BOWL_SIDE_R"
  });

  // Curved bottom (a circle placed below the hole)
  // This gives a smooth slide; top is OPEN because we don't add any top collider.
  const bottom = Matter.Bodies.circle(bx, by + r * 0.8, r * 0.475, { // Moved up from 0.6 to 0.8 to bring top edge down
    ...mat, 
    label: "BOWL_BOTTOM"
  });

  // Scoring sensor (no physical push) â smaller than the visual hole
  const sensor = Matter.Bodies.circle(bx, by + r * 0.2, r * 0.55, {
    isStatic: true, 
    isSensor: true, 
    label: "BOWL_SENSOR"
  });

  Matter.World.add(world, [left, right, bottom, sensor]);



  // Return the bowl bodies for movement control
  return { left, right, bottom, sensor, centerX: bx, centerY: by, radius: r };
};

// Wire up scoring when the roll enters the bowl
const wireScoring = (engine, addScoreCallback) => {
  Matter.Events.on(engine, "collisionStart", (e) => {
    e.pairs.forEach(({ bodyA, bodyB }) => {
      const a = bodyA.label, b = bodyB.label;
      if ((a === "BOWL_SENSOR" && b === "TP") || (b === "BOWL_SENSOR" && a === "TP")) {
        console.log("SCORE! TP entered the bowl!");
        
        // Hide the TP sprite by setting it to off-screen
        const tpBody = a === "TP" ? bodyA : bodyB;
        Matter.Body.setPosition(tpBody, { x: -9999, y: -9999 });
        

        
        // Play water drop sound effect
        playWaterDropSound();
        
        // Add point
        addScoreCallback();
      }
    });
  });
};

// Create TP body
const createTP = () => {
  return Matter.Bodies.circle(-9999, -9999, CONSTANTS.TP_RADIUS, {
    label: "TP",
    restitution: 0.45,
    friction: 0.05,
    frictionAir: 0.012,
    density: 0.0016,
    isStatic: true, // keep the roll fixed until launch
  });
};

 const setupWorld = (addScoreCallback) => {
   const engine = Matter.Engine.create({ enableSleeping: false });
   const world = engine.world;
   // Set initial gravity - this should be the only place gravity is set initially
   world.gravity.x = 0;
   world.gravity.y = CONSTANTS.GRAVITY_Y;

  // Create TP first
  const tp = createTP();

  // Build clean arena
  buildArena(engine, WIDTH, HEIGHT, tp);
  
  // Remove any old rim that blocks the opening
  removeOldRims(engine);
  
  // Add open-top toilet bowl and store the bodies for movement
  const bowlBodies = addOpenBowl(engine, WIDTH / 2, HEIGHT * 0.45, 42); // Physics colliders positioned lower than visual
  
  // Wire up scoring
  wireScoring(engine, addScoreCallback);

  // Add TP body to the world
  Matter.World.add(world, tp);


  // Remove any old debug colliders
  Matter.Composite.allBodies(engine.world).forEach(b => {
    if (!["BOUNDARY", "BOWL_SIDE_L", "BOWL_SIDE_R", "BOWL_BOTTOM", "BOWL_SENSOR", "TP"].includes(b.label)) {
      Matter.World.remove(engine.world, b);
    }
  });

  // Ensure boundary walls are always present
  const boundaryWalls = Matter.Composite.allBodies(engine.world).filter(b => b.label === "BOUNDARY");
  if (boundaryWalls.length < 4) {
    console.warn("Missing boundary walls! Rebuilding arena...");
    buildArena(engine, WIDTH, HEIGHT, tp);
  }



  return { engine, world, bodies: { tp, bowlBodies } };
};

/******************** Systems ********************/
// Fixed-step physics
const Physics = (entities, { time }) => {
  const engine = entities.physics.engine;
  Matter.Engine.update(engine, time?.delta || 16.666);
  return entities;
};



// Handle end-turn when touching ground
const CollisionSystem = (entities, { events }) => {
  // We subscribe to Matter collision events once in App; here just read flags from entities.state
  return entities;
};

// Moving toilet system
const MovingToiletSystem = (entities, { time }) => {
  const { engine, world, bodies } = entities.physics;
  const bowlBodies = bodies?.bowlBodies;
  
  if (!bowlBodies) {
    return entities;
  }
  
  // Initialize movement state if not exists
  if (!entities.toiletMovement) {
    const centerX = WIDTH / 2; // Start exactly in the center
    entities.toiletMovement = {
      direction: -1, // Start moving left first
      speed: 0.8, // pixels per frame
      leftBound: centerX - 150, // 150 pixels left from center
      rightBound: centerX + 150, // 150 pixels right from center
      currentX: centerX,
      frameCount: 0
    };
  }
  
  const movement = entities.toiletMovement;
  
  // Apply speed multiplier for endless plunge
  const speedMul = entities.endlessRef?.current?.toiletSpeedMul || 1;
  const effSpeed = movement.speed * speedMul;
  
  // Update position
  movement.currentX += movement.direction * effSpeed;
  
  // Check bounds and reverse direction
  if (movement.currentX <= movement.leftBound) {
    movement.currentX = movement.leftBound;
    movement.direction = 1; // start moving right
  } else if (movement.currentX >= movement.rightBound) {
    movement.currentX = movement.rightBound;
    movement.direction = -1; // start moving left
  }
  
  // Move all bowl bodies together
  const newCenterX = movement.currentX;
  const centerY = bowlBodies.centerY;
  const r = bowlBodies.radius;
  
  // Update left wall position
  Matter.Body.setPosition(bowlBodies.left, {
    x: newCenterX - r * 0.9,
    y: centerY + r * 0.1
  });
  
  // Update right wall position
  Matter.Body.setPosition(bowlBodies.right, {
    x: newCenterX + r * 0.9,
    y: centerY + r * 0.1
  });
  
  // Update bottom position
  Matter.Body.setPosition(bowlBodies.bottom, {
    x: newCenterX,
    y: centerY + r * 0.8
  });
  
  // Update sensor position
  Matter.Body.setPosition(bowlBodies.sensor, {
    x: newCenterX,
    y: centerY + r * 0.2
  });
  
  // Update the stored center position
  bowlBodies.centerX = newCenterX;
  
  // Increment frame count
  entities.toiletMovement.frameCount++;
  
  return entities;
};

/******************** Main Component ********************/
export default function ToiletPaperToss({ onGameComplete, gameMode, sheetRef }) {
  const gameRef = useRef(null);
  const [ready, setReady] = useState(false);
  const [score, setScore] = useState(0);
  const [highScore, setHighScore] = useState(0);
  const [persistentHighScore, setPersistentHighScore] = useState(0);

  const [timeLeft, setTimeLeft] = useState(0);
  const [gameOverVisible, setGameOverVisible] = useState(false);

  const [isMuted, setIsMuted] = useState(false);
  const [settingsVisible, setSettingsVisible] = useState(false);
  const [tpPos, setTpPos] = useState({ x: -9999, y: -9999 });
  const [tpVisible, setTpVisible] = useState(false);
  const [toiletPos, setToiletPos] = useState({ x: WIDTH / 2, y: HEIGHT * 0.40 });

  // ===== Endless Plunge Round State =====
  const [epRound, setEpRound] = useState(1);           // starts at Round 1
  const [epTimeLeft, setEpTimeLeft] = useState(30);    // seconds remaining in current round
  const [epTarget, setEpTarget] = useState(10);        // points required this round
  const [epRoundPoints, setEpRoundPoints] = useState(0);
  const [toiletSpeedMul, setToiletSpeedMul] = useState(1); // 1.0 -> 1.5 (capped)
  const [tpSkin, setTpSkin] = useState('tp.png');
  
  // ===== Level Up Banner State =====
  const [showLevelUp, setShowLevelUp] = useState(false);
  const [isTimerPaused, setIsTimerPaused] = useState(false);
  const prevRound = useRef(1);
  const insets = useSafeAreaInsets();

  // ===== Practice Mode Customization State =====
  const [practiceCustomizationVisible, setPracticeCustomizationVisible] = useState(false);
  const [practiceSettings, setPracticeSettings] = useState({
    tpSkin: 'tp.png',
    toiletSpeed: 5,
    gravity: 5,
  });
  const [practiceGameStarted, setPracticeGameStarted] = useState(false);
  

     // Removed dynamic gravity and speed state - using constants only

  // convenience ref so physics/tickers can read latest values without stale closures
  const endlessRef = useRef({
    round: 1,
    timeLeft: 30,
    target: 10,
    roundPoints: 0,
    toiletSpeedMul: 1,
    tpSkin: 'tp.png',
    running: false,            // is a round currently active
  });
  


  // Use ref to store scoring callback
  const addScoreRef = useRef(null);

  const [enginePkg] = useState(() => {
    const worldSetup = setupWorld(() => {
      if (addScoreRef.current) {
        addScoreRef.current();
      }
    });
    

    
    return worldSetup;
  });
  const { engine, world, bodies } = enginePkg;

  // Simple scoring functions (no persistent storage for now)
  const addScore = () => {
    const newScore = score + 1;
    setScore(newScore);
    
    // Update high score if needed (session only)
    if (newScore > highScore) {
      setHighScore(newScore);
    }
    
    // For endless plunge, save high score periodically to ensure it's tracked
    if (gameMode === 'endless-plunge' && newScore > persistentHighScore) {
      saveHighScore(newScore).then(() => {
        setPersistentHighScore(newScore);
      }).catch(error => {
        console.log('Error saving high score:', error);
      });
    }

    // Endless Plunge round scoring
    if (gameMode === 'endless-plunge' && endlessRef.current.running) {
      setEpRoundPoints(p => {
        const newPoints = p + 1;
        console.log('Round points updated:', newPoints, '/', endlessRef.current.target);
        
        // Don't auto-advance - let the level up banner handle it
        // The banner will trigger and pause the game, then advance when complete
        
        return newPoints;
      });
    }
  };

  // Update the ref when addScore changes
  useEffect(() => {
    addScoreRef.current = addScore;
  }, [score, highScore]);

  // Keep endless ref in sync with state
  useEffect(() => { endlessRef.current.round = epRound; }, [epRound]);
  useEffect(() => { endlessRef.current.timeLeft = epTimeLeft; }, [epTimeLeft]);
  useEffect(() => { endlessRef.current.target = epTarget; }, [epTarget]);
  useEffect(() => { endlessRef.current.roundPoints = epRoundPoints; }, [epRoundPoints]);
  useEffect(() => { 
    // Pause toilet movement during level up celebration
    endlessRef.current.toiletSpeedMul = isTimerPaused ? 0 : toiletSpeedMul; 
  }, [toiletSpeedMul, isTimerPaused]);
  useEffect(() => { endlessRef.current.tpSkin = tpSkin; }, [tpSkin]);

  // Detect when points reach target and trigger level up banner
  const levelUpTriggeredRef = useRef(false);
  
  useEffect(() => {
    if (epRoundPoints >= epTarget && epRoundPoints > 0 && !levelUpTriggeredRef.current) {
      // Points reached target - trigger level up!
      levelUpTriggeredRef.current = true;
      setShowLevelUp(true);
    }
  }, [epRoundPoints, epTarget]);
  
  // Reset trigger when round changes
  useEffect(() => {
    levelUpTriggeredRef.current = false;
  }, [epRound]);

  // Show practice customization modal when Practice Mode is selected
  useEffect(() => {
    if (gameMode === 'quick-flush' && !practiceGameStarted) {
      setPracticeCustomizationVisible(true);
    }
  }, [gameMode]);

  // Round math helpers
  const TP_SKINS = ['tp.png','tp-blue.png','tp-green.png','tp-pink.png','tp-purple.png','tp-red.png','tp-orange.png','tp-rainbow.png'];

  function pickRandomSkin(exclude) {
    const pool = TP_SKINS.filter(s => s !== exclude && s !== 'tp.png'); // Exclude default skin from random selection
    return pool[Math.floor(Math.random() * pool.length)];
  }

  // First round: 30s/10pts
  // Every round after: +5s time, +2 points, +5% speed (cap at +50%)
  function getRoundConfig(round) {
    if (round === 1) {
      return { time: 30, target: 10, speedMul: 1.0 };
    }
    
    const extraRounds = round - 1;
    const time = 30 + (extraRounds * 5); // 35s at round 2, 40s at round 3, etc.
    const target = 10 + (extraRounds * 2); // 12 at round 2, 14 at round 3, etc.
    
    // Speed increases by 5% each round, capped at +50% (1.5x total)
    const speedIncrease = Math.min(extraRounds * 0.05, 0.50);
    const speedMul = 1.0 + speedIncrease;
    
    return { time, target, speedMul };
  }

  // Kick off Endless Plunge session (Round 1)
  function startEndlessPlungeSession() {
    console.log('Starting Endless Plunge session');
    setEpRound(1);
    const cfg = getRoundConfig(1);
    console.log('Round 1 config:', cfg);
    setEpTimeLeft(cfg.time);
    setEpTarget(cfg.target);
    setEpRoundPoints(0);
    setToiletSpeedMul(cfg.speedMul);
    setTpSkin(pickRandomSkin(undefined));
    endlessRef.current.running = true;
    // ensure any miss counters stop affecting endless mode; your code may already do this
  }



  // Advance to next round (after win) or end game (after fail)
  async function advanceOrEndRound(won) {
    console.log('advanceOrEndRound called with won:', won, 'current round:', epRound);
    
    if (!won) {
      // Show your existing game over modal
      showGameOver();
      endlessRef.current.running = false;
      return;
    }

    // Next round setup
    const next = epRound + 1;
    const cfg = getRoundConfig(next);
    console.log('Advancing to round', next, 'with config:', cfg);
    
    setEpRound(next);
    setEpTimeLeft(cfg.time);
    setEpTarget(cfg.target);
    setEpRoundPoints(0);
    setToiletSpeedMul(cfg.speedMul);
    setTpSkin(prev => pickRandomSkin(prev));
    endlessRef.current.running = true;
    
    // Note: The level up celebration will be triggered by the useEffect that watches epRound
  }

  const showGameOver = () => {
    // Just show the game over modal - let the buttons handle navigation
    setGameOverVisible(true);
  };

     // Use fixed default speed - no dynamic calculations
   const getAdjustedSpeed = () => {
     return 16.2; // Fixed default speed for all modes
   };

     // Practice Mode Customization Handlers
   const handlePracticePlay = (settings) => {
     setPracticeSettings(settings);
     setPracticeCustomizationVisible(false);
     setPracticeGameStarted(true);
     
     // Apply practice settings
     setTpSkin(settings.tpSkin);
     
     // Update toilet speed for practice mode
     const toiletSpeedMultiplier = settings.toiletSpeed / 5; // Convert 0-10 to 0-2x multiplier
     setToiletSpeedMul(toiletSpeedMultiplier);
     
     // Gravity and speed are now fixed constants
   };

  const handlePracticeClose = () => {
    setPracticeCustomizationVisible(false);
    // Navigate back to home screen or handle as needed
    if (onGameComplete) {
      onGameComplete();
    }
  };





  // Keep last aim from AimPad
  const lastAimRef = useRef(null);

  // Bulletproof launch function
  const doLaunch = () => {
    const a = lastAimRef.current;
    if (!a) { return; }

    // Despawn any existing TP first
    if (bodies?.tp) {
      Matter.World.remove(world, bodies.tp);
      bodies.tp = null;
    }

    // Create a new TP body
    const newTp = Matter.Bodies.circle(-9999, -9999, CONSTANTS.TP_RADIUS, {
      restitution: 0.45,
      friction: 0.05,
      frictionAir: 0.012,
      density: 0.0016,
      label: 'TP'
    });

    // Add to world
    Matter.World.add(world, newTp);
    bodies.tp = newTp;

    // spawn at the visual center of the aimpad
    const spawn = { 
      x: WIDTH / 2,  // Center horizontally
      y: HEIGHT - 24 - 74.25  // Bottom: 24, aimpad radius: 74.25
    };

    // Ensure spawn coordinates are valid numbers
    if (!Number.isFinite(spawn.x) || !Number.isFinite(spawn.y)) {
      return;
    }

    // wake + place
    Matter.Body.setStatic(newTp, false);
    Matter.Sleeping.set(newTp, false);
    Matter.Body.setPosition(newTp, spawn);
    Matter.Body.setVelocity(newTp, { x: 0, y: 0 });
    Matter.Body.setAngularVelocity(newTp, 0);

    // power from AimPad drag distance; add a safe minimum
    const rawP = a.power || 0;
    const p = Math.max(0.25, Math.min(1, rawP));     // TEMP min power 25%
    const SPEED = getAdjustedSpeed();  // Use gravity-adjusted speed

    // Apply velocity - AxisAimPad provides dy where up is negative, so we need to negate it
    const vx = (a.dir?.x || 0) * SPEED * p;
    const vy = -(a.dir?.y || 0) * SPEED * p; // Negate dy so up becomes positive

    Matter.Body.setVelocity(newTp, { x: vx, y: vy });
    Matter.Body.setAngularVelocity(newTp, 0.2 * p);

         // Debug logging (commented out to prevent performance issues)
     // console.log('Launch:', { 
     //   spawn, 
     //   velocity: { x: vx, y: vy }, 
     //   power: p, 
     //   speed: SPEED,
     //   dir: a.dir 
     // });

    // FIRST-FRAME SYNC + show sprite in the SAME component that renders it
    // Force immediate sync to prevent afterUpdate from overwriting
    setTpPos(spawn);
    setTpVisible(true);
    
    // Reset turn state for new TP roll
    stateRef.current.turnOver = false;
    stateRef.current.missCounted = false;
  };

  const stateRef = useRef({
    aiming: false,
    dragStart: { x: CONSTANTS.START_X, y: CONSTANTS.START_Y },
    dragCurrent: { x: CONSTANTS.START_X, y: CONSTANTS.START_Y },
    turnOver: false,
    // AimPad controls
    padActive: false,
    padPower: 0,
    padOrigin: null,
    padVel: null,
  });



  // Load sounds
  useEffect(() => {
    loadSounds();
    return () => {
      if (dingSound) {
        dingSound.unloadAsync();
      }
    };
  }, []);



  // Load persistent high score on mount
  useEffect(() => {
    const loadHighScoreData = async () => {
      try {
        const highScoreRecord = await loadHighScore();
        if (highScoreRecord && highScoreRecord.highScore > 0) {
          setPersistentHighScore(highScoreRecord.highScore);
          setHighScore(highScoreRecord.highScore); // Also set session high score
        }
      } catch (error) {
        console.log('Error loading high score:', error);
      }
    };
    loadHighScoreData();
  }, [gameMode]);

  // Initialize endless plunge session when game mode changes
  useEffect(() => {
    if (gameMode === 'endless-plunge') {
      startEndlessPlungeSession();
    }
  }, [gameMode]);



  // Handle game completion and save high score
  const handleGameComplete = async (finalScore) => {
    try {
      if (finalScore > persistentHighScore) {
        // New high score achieved!
        await saveHighScore(finalScore);
        setPersistentHighScore(finalScore);
        setHighScore(finalScore);
      }
    } catch (error) {
      console.log('Error saving high score:', error);
    }
    
    // Call the original onGameComplete callback
    if (onGameComplete) {
      onGameComplete(finalScore);
    }
  };

  // Apply mute state to loaded sounds
  useEffect(() => {
    const applyVolume = async () => {
      if (dingSound) {
        try {
          await dingSound.setVolumeAsync(isMuted ? 0 : 1);
        } catch (e) {
          // ignore
        }
      }
      try {
        await Audio.setIsEnabledAsync(!isMuted);
      } catch {}
    };
    applyVolume();
  }, [isMuted]);

  // Game timer (removed for Practice Mode - game only ends on user action)

  // Endless Plunge timer ticker (1 Hz)
  useEffect(() => {
    if (gameMode !== 'endless-plunge') return;
    let id = null;

    const tick = () => {
      if (!endlessRef.current.running || isTimerPaused) return; // Don't tick when paused
      setEpTimeLeft(t => {
        if (t <= 1) {
          // time is up -> win if target met, else lose
          // Use current state values instead of ref to avoid stale closure issues
          const won = epRoundPoints >= epTarget;
          console.log('Time up! Round points:', epRoundPoints, 'Target:', epTarget, 'Won:', won);
          // stop this round before advancing
          endlessRef.current.running = false;
          // small delay so UI can show 0
          setTimeout(() => advanceOrEndRound(won), 100);
          return 0;
        }
        return t - 1;
      });
    };

    id = setInterval(tick, 1000);
    return () => { if (id) clearInterval(id); };
  }, [gameMode, epRoundPoints, epTarget, isTimerPaused]); // Include dependencies to avoid stale closures

  // Collision handling: if tp hits ground, mark turn over
  useEffect(() => {
    const onCollide = (e) => {
      const pairs = e.pairs || [];
      for (const p of pairs) {
        const labels = [p.bodyA.label, p.bodyB.label];
        
        // Note: Bowl scoring is handled by wireScoring function, so we don't duplicate it here
        // Miss detection is now handled in afterUpdate loop for more precise control
      }
    };
    Matter.Events.on(engine, 'collisionStart', onCollide);
    return () => Matter.Events.off(engine, 'collisionStart', onCollide);
  }, [engine, bodies.tp, tpVisible, gameMode]);

  // Reset turn state when a new TP roll is launched
  useEffect(() => {
    if (!stateRef.current.turnOver) {
      // Reset UI state when turn is active
      stateRef.current.aiming = false;
    }
  }, [stateRef.current.turnOver]);

     // Physics runner and position mirroring
   useEffect(() => {
     const engine = enginePkg.engine;

     
     const runner = Matter.Runner.create();
     Matter.Runner.run(runner, engine);

           // Gravity is now handled by the separate useEffect
    
        let updateCount = 0;
    Matter.Events.on(engine, "afterUpdate", () => {
      updateCount++;
      
      const tp = bodies?.tp;
      if (!tp) {
        return;
      }
      const p = tp.position;
      
      // Always update tpPos if TP is visible and position is valid
      if (tpVisible && Number.isFinite(p.x) && Number.isFinite(p.y)) {
        setTpPos({ x: p.x, y: p.y });
      }
      
             // Hide and despawn TP if it falls below the aimpad or too far below the screen
       if (tpVisible && (tp.position.y > HEIGHT - 24 || tp.position.y > HEIGHT + 100)) {
         setTpVisible(false);
         // Remove the TP body from the world
         if (bodies?.tp) {
           Matter.World.remove(world, bodies.tp);
           bodies.tp = null;
         }
       }
      
      // Update toilet position to match bowl colliders (only if bowlBodies exists)
      const bowlBodies = bodies?.bowlBodies;
      if (bowlBodies && Number.isFinite(bowlBodies.centerX)) {
        setToiletPos({ 
          x: bowlBodies.centerX, 
          y: HEIGHT * 0.40 
        });
      }
    });

    return () => {
      Matter.Events.off(engine, "afterUpdate");
      Matter.Engine.clear(engine);
    };
     }, [enginePkg, bodies.tp, gameMode, tpVisible]);

   // Set gravity once and keep it fixed
   useEffect(() => {
     if (engine) {
       engine.world.gravity.x = 0;
       engine.world.gravity.y = CONSTANTS.GRAVITY_Y; // Always use the constant
     }
   }, [engine]);

  // Input handled via AimPad
  const systems = [Physics, CollisionSystem, MovingToiletSystem];

  const [tick, setTick] = useState(0);
  useEffect(() => {
    // Force a slow UI refresh for HUD ~30fps without spamming state
    const id = setInterval(() => setTick((t) => t + 1), 33);
    setReady(true);
    
    return () => clearInterval(id);
  }, []);

  const state = stateRef.current;

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <View style={styles.container}>

      {/* New GameHUD Component */}
      {gameMode === 'endless-plunge' && (
        <GameHUD
          gameMode={gameMode}
          round={epRound}
          points={epRoundPoints}
          timeLeft={epTimeLeft}
          pointsRemaining={Math.max(0, epTarget - epRoundPoints)}
          totalScore={score}
          roundTarget={epTarget}
          isMuted={isMuted}
          onToggleMute={() => setIsMuted(m => !m)}
          onOpenSettings={() => setSettingsVisible(true)}
          onEndGame={() => {
            endlessRef.current.running = false;
            showGameOver();
          }}
        />
      )}

      {/* Level Up Banner */}
      {gameMode === 'endless-plunge' && (
        <LevelUpBanner
          visible={showLevelUp}
          round={epRound + 1} // Show the round we're advancing to
          onStart={() => setIsTimerPaused(true)} // Pause timer when celebration starts
          onComplete={() => {
            setShowLevelUp(false);
            setIsTimerPaused(false); // Resume timer after celebration
            // Advance to next round after celebration
            advanceOrEndRound(true);
          }}
        />
      )}
      
      {/* Quick Flush HUD - simplified version */}
      {gameMode === 'quick-flush' && (
        <GameHUD
          gameMode={gameMode}
          round={1}
          points={score}
          timeLeft={0}
          pointsRemaining={0}
          totalScore={score}
          roundTarget={0}
          isMuted={isMuted}
          onToggleMute={() => setIsMuted(m => !m)}
          onOpenSettings={() => setSettingsVisible(true)}
          onEndGame={() => {
            showGameOver();
          }}
        />
      )}
      


      {/* Game Area */}
      <ImageBackground 
        source={require('../../assets/game_background.png')} 
        style={styles.gameArea}
        resizeMode="stretch"
      >
        <GameEngine
          ref={gameRef}
          style={styles.game}
          systems={systems}
          entities={{
            physics: { engine, world, bodies },
            state,
            endlessRef, // Pass the ref so systems can access endless plunge state
            tp: { body: bodies.tp, renderer: null }, // TP now rendered separately
          }}
        >
          {/* HUD removed: old trajectory indicator */}
        </GameEngine>

        {/* New overlay + AimPad */}
        <TrajectoryOverlay
          origin={state.padOrigin || { x: WIDTH / 2, y: HEIGHT - 24 - 56 }}
          vel={state.padVel || null}
          gravityY={CONSTANTS.GRAVITY_Y}
          visible={!!state.padActive}
          steps={26}
          dt={1/30}
        />

        <View style={{
          position: 'absolute',
          bottom: 24,
          left: 0,
          right: 0,
          alignItems: 'center',
          justifyContent: 'center',
        }}>
          <AxisAimPad
            size={148.5}          // AxisPad takes diameter (74.25 * 2)
            deadZone={0.08}       // matches your previous dead zone
            powerCurve={1.0}      // linear like the Snack
            snapBackOnRelease     // center stick on release (Snack behavior)
            showPowerBar          // enable the built-in aim/power bar
            onVector={({ dx, dy, power, angle, origin }) => {
              // keep all your existing state logic intact
              stateRef.current.padActive = true;
              stateRef.current.padPower = power;
              stateRef.current.padOrigin = origin;          // keep origin for trajectory overlay
              const PAD_SPEED = 12;                          // your existing constant
              stateRef.current.padVel = {
                x: dx * PAD_SPEED,
                y: dy * PAD_SPEED,
              };
              
              // Update lastAimRef for doLaunch
              lastAimRef.current = { 
                dir: { x: dx, y: dy }, 
                power, 
                origin 
              };
            }}
            onLaunch={({ dx, dy, power, angle, origin }) => {
              stateRef.current.padActive = false;
              // Your doLaunch() uses stateRef.current.padVel/power already,
              // so just ensure those are final before calling.
              const PAD_SPEED = 12;
              stateRef.current.padVel = { x: dx * PAD_SPEED, y: dy * PAD_SPEED };
              stateRef.current.padPower = power;
              stateRef.current.padOrigin = origin;
              
              // Update lastAimRef for doLaunch
              lastAimRef.current = { 
                dir: { x: dx, y: dy }, 
                power, 
                origin 
              };
              
              doLaunch();
            }}
          />
        </View>

        {/* Debug: Visualize static bodies (temporarily disabled) */}
        {/* <StaticBodiesOverlay engine={engine} /> */}
        
        {/* Debug: Show bowl hitbox (temporarily disabled) */}
        {/* <BowlHitboxOverlay engine={engine} /> */}

        {/* Toilet sprite (visual only, no physics) */}
        <View style={{
          position: 'absolute',
          left: toiletPos.x - 160,
          top: toiletPos.y - 160,
          width: 320,
          height: 320,
          zIndex: 10,
        }}>
          <Image
            source={require('../../assets/toilet.png')}
            style={{ width: '100%', height: '100%' }}
            resizeMode="contain"
          />
        </View>

        {/* TP sprite â bulletproof rendering with rotation */}
        {tpVisible && bodies.tp && Number.isFinite(tpPos.x) && Number.isFinite(tpPos.y) && (
          <Image
            source={(() => {
              const skinMap = {
                'tp.png':        require('../../assets/tp.png'),
                'tp-blue.png':   require('../../assets/tp-blue.png'),
                'tp-green.png':  require('../../assets/tp-green.png'),
                'tp-pink.png':   require('../../assets/tp-pink.png'),
                'tp-purple.png': require('../../assets/tp-purple.png'),
                'tp-red.png':    require('../../assets/tp-red.png'),
                'tp-orange.png': require('../../assets/tp-orange.png'),
                'tp-rainbow.png': require('../../assets/tp-rainbow.png'),
              };
              return skinMap[tpSkin] || skinMap['tp.png'];
            })()}
            style={{ 
              position:'absolute', 
              left: tpPos.x - 28, 
              top: tpPos.y - 28, 
              width:56, 
              height:56, 
              zIndex:20,
              transform: [{ rotate: `${bodies.tp?.angle * (180 / Math.PI) || 0}deg` }] // Convert radians to degrees
            }}
            resizeMode="contain"
            onLoad={() => {}}
            onError={(error) => {
              console.error('TP image failed to load:', error);
              // Only show red circle if image fails to load
            }}
          />
        )}
        
        {/* Debug: Show TP position as a simple colored circle ONLY if image fails */}
        {/* {tpVisible && Number.isFinite(tpPos.x) && Number.isFinite(tpPos.y) && (
          <View
            style={{
              position: 'absolute',
              left: tpPos.x - 28,
              top: tpPos.y - 28,
              width: 56,
              height: 56,
              borderRadius: 28,
              backgroundColor: '#FF6B6B',
              borderWidth: 2,
              borderColor: '#fff',
              zIndex: 19
            }}
          />
        )} */}


      </ImageBackground>

      <Modal
        transparent
        animationType="fade"
        visible={settingsVisible}
        onRequestClose={() => setSettingsVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.modalCard}>
            <Text style={styles.modalTitle}>Settings</Text>
            <Text style={styles.modalText}>Coming soon.</Text>
            <TouchableOpacity onPress={() => setSettingsVisible(false)} style={styles.modalButton}>
              <Text style={styles.modalButtonText}>Close</Text>
            </TouchableOpacity>
          </View>
        </View>
                      </Modal>

      {/* Practice Customization Modal */}
      <PracticeCustomizationModal
        visible={practiceCustomizationVisible}
        onPlay={handlePracticePlay}
        onClose={handlePracticeClose}
        availableTpSkins={TP_SKINS}
      />

      {/* Game Over Modal */}
      <Modal
        transparent
        animationType="fade"
        visible={gameOverVisible}
        onRequestClose={() => setGameOverVisible(false)}
      >
        <View style={styles.modalOverlay}>
          <View style={styles.gameOverModalCard}>
            {/* Background gradient effect */}
            <View style={styles.modalBackgroundGradient} />
            
            {/* Header with game mode icon */}
            <View style={styles.gameOverHeader}>
              <View style={styles.headerIconContainer}>
                <Ionicons 
                  name={gameMode === 'quick-flush' ? 'flash' : 'game-controller'} 
                  size={14} 
                  color="#3B82F6" 
                />
              </View>
              <Text style={styles.gameOverTitle}>
                {gameMode === 'endless-plunge' ? 'Plunge Complete!' : 'Game Complete!'}
              </Text>
            </View>
            
            {/* Endless Plunge specific stats */}
            {gameMode === 'endless-plunge' ? (
              <View style={styles.endlessStatsSection}>
                {/* Round reached */}
                <View style={styles.statCard}>
                  <View style={[styles.statIconContainer, { backgroundColor: 'rgba(59, 130, 246, 0.15)', borderColor: '#3B82F6' }]}>
                    <Ionicons name="infinite" size={14} color="#3B82F6" />
                  </View>
                  <View style={styles.statContent}>
                    <Text style={styles.statLabel}>Round</Text>
                    <Text style={styles.statValue}>{epRound}</Text>
                  </View>
                </View>
                
                {/* Total score */}
                <View style={styles.statCard}>
                  <View style={[styles.statIconContainer, { backgroundColor: 'rgba(245, 158, 11, 0.15)', borderColor: '#F59E0B' }]}>
                    <Ionicons name="star" size={14} color="#F59E0B" />
                  </View>
                  <View style={styles.statContent}>
                    <Text style={styles.statLabel}>Score</Text>
                    <Text style={styles.statValue}>{score}</Text>
                  </View>
                </View>
                
                {/* High score */}
                <View style={styles.statCard}>
                  <View style={[styles.statIconContainer, { backgroundColor: 'rgba(239, 68, 68, 0.15)', borderColor: '#EF4444' }]}>
                    <Ionicons name="trophy" size={14} color="#EF4444" />
                  </View>
                  <View style={styles.statContent}>
                    <Text style={styles.statLabel}>Best</Text>
                    <Text style={styles.statValue}>{persistentHighScore}</Text>
                  </View>
                </View>
              </View>
            ) : (
              /* Quick Flush stats (original design) */
              <View style={styles.scoreSection}>
                <View style={styles.scoreCard}>
                  <View style={styles.scoreCardHeader}>
                    <Ionicons name="star" size={14} color="#FFD700" />
                    <Text style={styles.scoreCardTitle}>Your Score</Text>
                  </View>
                  <Text style={styles.finalScoreValue}>{score}</Text>
                </View>
                
                <View style={styles.scoreCard}>
                  <View style={styles.scoreCardHeader}>
                    <Ionicons name="trophy" size={14} color="#E91E63" />
                    <Text style={styles.scoreCardTitle}>Best Score</Text>
                  </View>
                  <Text style={styles.highScoreValue}>{persistentHighScore}</Text>
                </View>
              </View>
            )}
            
            {/* New record celebration */}
            {score === persistentHighScore && score > 0 && (
              <View style={styles.newRecordContainer}>
                <Ionicons name="sparkles" size={14} color="#E91E63" />
                <Text style={styles.newRecordText}>NEW RECORD!</Text>
                <Ionicons name="sparkles" size={14} color="#E91E63" />
              </View>
            )}
            
            {/* Action buttons */}
            <View style={styles.actionButtonsContainer}>
              <TouchableOpacity 
                onPress={() => {
                  setGameOverVisible(false);
                  // Restart the same game mode
                  onGameComplete && onGameComplete(score, true);
                }} 
                style={styles.playAgainButton}
              >
                <Ionicons name="play" size={14} color="#FFFFFF" />
                <Text style={styles.playAgainButtonText}>Play Again</Text>
              </TouchableOpacity>
              
              <TouchableOpacity 
                onPress={() => {
                  setGameOverVisible(false);
                  // Go to main menu
                  onGameComplete && onGameComplete(score, false);
                }} 
                style={styles.menuButton}
              >
                <Ionicons name="home" size={14} color="#4A5568" />
                <Text style={styles.menuButtonText}>Main Menu</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

/******************** Styles ********************/
const styles = StyleSheet.create({
  container: { 
    flex: 1, 
    backgroundColor: '#f8fafc' 
  },








  gameArea: {
    flex: 1,
    position: 'relative',
  },
  game: { 
    flex: 1, 
    backgroundColor: 'transparent' 
  },
  shootWrap: {
    position: 'absolute',
    left: 0,
    right: 0,
    bottom: 24,
    alignItems: 'center',
    justifyContent: 'center',
  },
  shootButton: {
    width: 110,
    height: 110,
    alignItems: 'center',
    justifyContent: 'center',
  },
  toiletContainer: {
    position: 'absolute',
    width: 270,
    height: 240,
    zIndex: 10,
    alignItems: 'center',
    justifyContent: 'center',
  },
  toiletImage: {
    width: 270,
    height: 240,
  },
  titleWrap: { 
    position: 'absolute', 
    top: 20, 
    width: '100%', 
    alignItems: 'center' 
  },
  title: { 
    color: '#fff', 
    fontSize: 22, 
    fontWeight: '700' 
  },
  subtitle: { 
    color: '#9aa3b2', 
    fontSize: 12, 
    marginTop: 4 
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    alignItems: 'center',
    justifyContent: 'center',
  },
  modalCard: {
    width: '80%',
    backgroundColor: '#fff',
    borderRadius: 12,
    padding: 20,
    alignItems: 'center',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '700',
    marginBottom: 8,
    color: '#212529',
  },
  modalText: {
    fontSize: 14,
    color: '#495057',
    marginBottom: 16,
  },
  modalButton: {
    backgroundColor: '#4ECDC4',
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  modalButtonText: {
    color: '#fff',
    fontWeight: '600',
  },
  // Game Over Modal Styles
  gameOverModalCard: {
    width: '85%',
    backgroundColor: '#FFFFFF',
    borderRadius: 12,
    padding: 16,
    alignItems: 'center',
    borderWidth: 1.5,
    borderColor: '#E2E8F0',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.2,
    shadowRadius: 12,
    elevation: 8,
    position: 'relative',
    overflow: 'hidden',
  },
  modalBackgroundGradient: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: 'rgba(74, 85, 104, 0.1)',
    borderRadius: 24,
  },
  gameOverHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 12,
    gap: 8,
  },
  headerIconContainer: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(59, 130, 246, 0.2)',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1.5,
    borderColor: '#3B82F6',
  },
  gameOverTitle: {
    fontSize: 16,
    fontWeight: '900',
    color: '#2D3748',
    textTransform: 'uppercase',
    letterSpacing: 0.3,
    textShadowColor: 'rgba(0, 0, 0, 0.1)',
    textShadowOffset: { width: 0.5, height: 0.5 },
    textShadowRadius: 1,
  },
  scoreSection: {
    width: '100%',
    marginBottom: 16,
    gap: 8,
  },
  endlessStatsSection: {
    width: '100%',
    marginBottom: 12,
    gap: 8,
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  statCard: {
    flex: 1,
    alignItems: 'center',
    backgroundColor: '#F7FAFC',
    borderRadius: 8,
    padding: 8,
    borderWidth: 2,
    borderColor: '#000000',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
    marginHorizontal: 2,
  },
  statIconContainer: {
    width: 28,
    height: 28,
    borderRadius: 14,
    backgroundColor: 'rgba(74, 144, 226, 0.1)',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 1,
    borderColor: '#4A90E2',
  },
  statContent: {
    alignItems: 'center',
    marginTop: 4,
  },
  statLabel: {
    fontSize: 8,
    fontWeight: '700',
    color: '#4A5568',
    textTransform: 'uppercase',
    letterSpacing: 0.2,
    marginBottom: 1,
  },
  statValue: {
    fontSize: 16,
    fontWeight: '900',
    color: '#2D3748',
    textShadowColor: 'rgba(0, 0, 0, 0.05)',
    textShadowOffset: { width: 0.25, height: 0.25 },
    textShadowRadius: 0.5,
  },
  scoreCard: {
    backgroundColor: 'rgba(255, 255, 255, 0.95)',
    borderRadius: 10,
    padding: 12,
    borderWidth: 2,
    borderColor: '#E2E8F0',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 8,
    elevation: 4,
  },
  scoreCardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 4,
    gap: 4,
  },
  scoreCardTitle: {
    fontSize: 10,
    fontWeight: '700',
    color: '#4A5568',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  finalScoreValue: {
    fontSize: 20,
    fontWeight: '900',
    color: '#4A90E2',
    textAlign: 'center',
    textShadowColor: 'rgba(0, 0, 0, 0.2)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  highScoreValue: {
    fontSize: 20,
    fontWeight: '900',
    color: '#E91E63',
    textAlign: 'center',
    textShadowColor: 'rgba(0, 0, 0, 0.2)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  newRecordContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: 'rgba(233, 30, 99, 0.15)',
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 8,
    marginBottom: 16,
    borderWidth: 2,
    borderColor: '#E91E63',
    gap: 4,
  },
  newRecordText: {
    color: '#E91E63',
    fontSize: 12,
    fontWeight: '800',
    textAlign: 'center',
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    textShadowColor: 'rgba(0, 0, 0, 0.5)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  actionButtonsContainer: {
    flexDirection: 'row',
    gap: 8,
    width: '100%',
  },
  playAgainButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#4ECDC4',
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 2,
    borderColor: '#2d3748',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 6,
    elevation: 4,
    gap: 4,
  },
  playAgainButtonText: {
    color: '#FFFFFF',
    fontWeight: '700',
    fontSize: 12,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  menuButton: {
    flex: 1,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.9)',
    borderRadius: 10,
    paddingHorizontal: 12,
    paddingVertical: 10,
    borderWidth: 2,
    borderColor: '#4a5568',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 6,
    elevation: 4,
    gap: 4,
  },
  menuButtonText: {
    color: '#4A5568',
    fontWeight: '700',
    fontSize: 12,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  // Old aim styles removed - now using imported components
});
